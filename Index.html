diff --git a/index.html b/index.html
new file mode 100644
index 0000000000000000000000000000000000000000..9bbcc2ef0a83de661ebba7b3ce184aab9ebb6ba5
--- /dev/null
+++ b/index.html
@@ -0,0 +1,1898 @@
+<!doctype html>
+<html lang="es">
+<head>
+  <meta charset="utf-8" />
+  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
+  <title>MR Studio Diamond v5.1 (Editor+MR Workflow)</title>
+  <script src="https://unpkg.com/omggif@1.0.10/omggif.js"></script>
+  <style>
+    * { box-sizing: border-box; user-select: none; }
+    body { margin: 0; overflow: hidden; background: transparent; font-family: 'Segoe UI', system-ui, sans-serif; color: #eee; }
+    #c { position: fixed; inset: 0; width: 100%; height: 100%; touch-action: none; z-index: 0; }
+
+    .ui-panel {
+      position: fixed; left: 20px; top: 20px; width: 420px; max-height: 95vh;
+      background: rgba(10, 10, 14, 0.95); backdrop-filter: blur(20px);
+      border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 16px;
+      padding: 18px; overflow-y: auto; z-index: 100;
+      box-shadow: 0 20px 50px rgba(0,0,0,0.8);
+      transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
+      scrollbar-width: thin; scrollbar-color: #444 transparent;
+    }
+    .ui-panel.hidden { transform: translateX(-440px); }
+
+    h2 { margin: 0 0 15px 0; font-size: 18px; color: #a29bfe; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
+    .sec-head { font-size: 11px; font-weight: 700; color: #aaa; margin: 15px 0 8px 0; text-transform: uppercase; letter-spacing: 0.5px; display:flex; align-items:center; gap:8px; }
+
+    .row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
+    label { font-size: 12px; flex: 1; color: #ccc; white-space: nowrap; font-weight: 500; }
+    input[type=range] { flex: 2; height: 4px; background: #333; border-radius: 2px; accent-color: #6c5ce7; cursor: pointer; }
+    .val { width: 50px; text-align: right; font-size: 11px; font-family: monospace; color: #a29bfe; }
+    select, input[type=file], textarea { width: 100%; background: #1e1e24; border: 1px solid #444; color: #eee; padding: 8px; border-radius: 8px; font-size: 11px; outline: none; }
+    textarea { min-height: 120px; font-family: ui-monospace, Menlo, Consolas, monospace; resize: vertical; }
+
+    button { flex: 1; padding: 12px; border-radius: 8px; border: none; font-size: 12px; font-weight: 700; cursor: pointer; color: white; background: #333; transition: 0.2s; }
+    button.primary { background: linear-gradient(135deg, #6c5ce7, #a29bfe); box-shadow: 0 4px 15px rgba(108,92,231,0.3); }
+    button.danger { background: rgba(255, 71, 87, 0.15); border: 1px solid rgba(255, 71, 87, 0.3); color: #ff7675; }
+    button.warn { background: rgba(253, 203, 110, 0.15); border: 1px solid rgba(253, 203, 110, 0.3); color: #ffeaa7; }
+    button.ghost { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); color: #ddd; }
+
+    .layer-list { max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 5px; margin-bottom: 10px; }
+    .layer-item {
+      padding: 10px; font-size: 12px; border-radius: 6px; cursor: move;
+      display: flex; align-items: center; gap: 10px; margin-bottom: 4px;
+      border: 1px solid transparent; transition: 0.2s;
+    }
+    .layer-item:hover { background: rgba(108, 92, 231, 0.15); }
+    .layer-item.active { background: rgba(108, 92, 231, 0.25); border-color: rgba(108, 92, 231, 0.5); color: white; }
+    .layer-item.dragging { opacity: 0.5; }
+
+    .toggle-ui { position: fixed; bottom: 25px; right: 25px; width: 50px; height: 50px; background: #1e1e24; border-radius: 50%; display: grid; place-items: center; font-size: 20px; border: 1px solid #555; z-index: 200; cursor: pointer; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
+    #vrBtn { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); padding: 14px 45px; background: linear-gradient(135deg, #6c5ce7, #0984e3); color: white; border-radius: 50px; border: none; font-weight: 800; cursor: pointer; z-index: 1000; display: none; box-shadow: 0 0 30px rgba(108,92,231,0.6); animation: pulse 2s infinite; }
+    @keyframes pulse { 0% {box-shadow: 0 0 20px rgba(108,92,231,0.6);} 50% {box-shadow: 0 0 40px rgba(108,92,231,0.8);} 100% {box-shadow: 0 0 20px rgba(108,92,231,0.6);} }
+
+    #modeBadge{
+      position: fixed; top: 18px; right: 18px; z-index: 1200;
+      background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12);
+      padding: 10px 12px; border-radius: 12px; font-size: 12px;
+      display:flex; gap:10px; align-items:center;
+      backdrop-filter: blur(10px);
+    }
+    #modeDot{ width:10px; height:10px; border-radius:50%; background:#55efc4; box-shadow: 0 0 18px rgba(85,239,196,0.6); }
+    #modeText{ color:#ddd; font-weight:800; letter-spacing:0.6px; }
+    #exitXrBtn{ display:none; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.16); background:rgba(255,255,255,0.08); color:#fff; cursor:pointer; font-weight:800; }
+
+    .loader { position: fixed; inset: 0; background: rgba(0,0,0,0.92); z-index: 5000; display: none; place-items: center; flex-direction: column; gap: 15px; color: #a29bfe; font-size: 14px; font-weight: bold; letter-spacing: 2px; }
+    .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top-color: #a29bfe; border-radius: 50%; animation: spin 1s infinite linear; }
+    @keyframes spin { to { transform: rotate(360deg); } }
+
+    .hint {
+      font-size: 11px; color: #9aa0a6; line-height: 1.3;
+      background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08);
+      padding: 10px; border-radius: 10px; margin-top: 10px;
+    }
+    .kbd { font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 11px; color:#fff;
+      background: rgba(255,255,255,0.12); padding: 2px 6px; border-radius: 7px; border: 1px solid rgba(255,255,255,0.12);
+    }
+
+    /* üé¨ VIDEO CONTROLS FLOTANTES */
+    #videoControls {
+      position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
+      background: rgba(10, 10, 14, 0.95); backdrop-filter: blur(20px);
+      border: 1px solid rgba(255,255,255,0.15); border-radius: 16px;
+      padding: 15px 20px; display: none; z-index: 150;
+      box-shadow: 0 10px 40px rgba(0,0,0,0.7);
+      min-width: 400px;
+    }
+    #videoControls.show { display: block; }
+    .vid-btn-row { display: flex; gap: 10px; align-items: center; margin-bottom: 12px; }
+    .vid-btn {
+      width: 40px; height: 40px; border-radius: 50%; background: #333;
+      border: 1px solid #555; display: grid; place-items: center;
+      cursor: pointer; transition: 0.2s; font-size: 18px;
+    }
+    .vid-btn:hover { background: #444; border-color: #6c5ce7; }
+    .vid-btn.active { background: #6c5ce7; border-color: #a29bfe; }
+    .vid-progress { flex: 1; height: 6px; background: #333; border-radius: 3px; cursor: pointer; position: relative; }
+    .vid-progress-bar { height: 100%; background: linear-gradient(90deg, #6c5ce7, #a29bfe); border-radius: 3px; width: 0%; transition: width 0.1s; }
+    .vid-time { font-size: 11px; color: #aaa; font-family: monospace; min-width: 100px; text-align: center; }
+
+    /* üé® CHROMA PRESETS */
+    .chroma-presets { display: flex; gap: 6px; flex-wrap: wrap; margin: 8px 0; }
+    .chroma-preset {
+      width: 32px; height: 32px; border-radius: 8px; cursor: pointer;
+      border: 2px solid transparent; transition: 0.2s;
+    }
+    .chroma-preset:hover { border-color: #6c5ce7; transform: scale(1.1); }
+    .chroma-preset.active { border-color: #a29bfe; box-shadow: 0 0 15px rgba(108,92,231,0.6); }
+
+    /* üì¶ 3D MODEL COMPONENTS */
+    .model-components { max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 8px; margin: 8px 0; }
+    .model-comp-item {
+      display: flex; align-items: center; gap: 8px; padding: 6px;
+      font-size: 11px; border-radius: 6px; margin-bottom: 4px;
+    }
+    .model-comp-item:hover { background: rgba(255,255,255,0.05); }
+    .model-comp-item input[type=checkbox] { width: 16px; height: 16px; }
+    .model-comp-item label { font-size: 11px; flex: 1; cursor: pointer; }
+
+    /* üéß AUDIO */
+    .audio-actions { display: flex; gap: 10px; margin-bottom: 8px; }
+  </style>
+</head>
+<body>
+
+<canvas id="c"></canvas>
+<div class="loader" id="loader"><div class="spinner"></div><span>CARGANDO...</span></div>
+
+<div id="modeBadge">
+  <div id="modeDot"></div>
+  <div id="modeText">MODO EDITOR</div>
+  <button id="exitXrBtn" title="Salir de XR para editar propiedades">SALIR A EDICI√ìN</button>
+</div>
+
+<!-- üé¨ CONTROLES DE VIDEO FLOTANTES -->
+<div id="videoControls">
+  <div class="vid-btn-row">
+    <div class="vid-btn" id="vidPlayPause" title="Play/Pause">‚ñ∂Ô∏è</div>
+    <div class="vid-btn" id="vidStop" title="Stop">‚èπÔ∏è</div>
+    <div class="vid-progress" id="vidProgress">
+      <div class="vid-progress-bar" id="vidProgressBar"></div>
+    </div>
+    <div class="vid-time" id="vidTime">0:00 / 0:00</div>
+  </div>
+  <div class="row">
+    <label>üîä Volumen</label>
+    <input type="range" id="vidVolume" min="0" max="1" step="0.01" value="1" style="flex:2;">
+    <span class="val" id="v_vidVolume">100</span>
+  </div>
+</div>
+
+<div class="ui-panel" id="ui">
+  <h2>ü•Ω MR Studio Diamond v5.1</h2>
+
+  <div class="sec-head">üìÇ Archivos <button class="warn" style="padding:4px; font-size:10px; width:auto; flex:0;" onclick="fileInput.click()">+ IMPORTAR</button></div>
+  <input type="file" id="fileInput" accept="image/*,video/*,audio/*,.gif,.glb,.gltf,.fbx,.obj,.frag,.glsl" multiple style="display:none;" />
+
+  <div class="layer-list" id="layerList"></div>
+
+  <div class="sec-head">üß≠ Editor (tipo Blender)</div>
+  <div class="row">
+    <label><input type="checkbox" id="checkGrid" checked> Grilla</label>
+    <label><input type="checkbox" id="checkAxes" checked> Ejes</label>
+  </div>
+  <div class="row">
+    <label><input type="checkbox" id="checkSnap"> Snap (0.25m)</label>
+    <label><input type="checkbox" id="checkGizmo" checked> Gizmos</label>
+  </div>
+
+  <div id="generalControls">
+    <div class="sec-head">üìç Proyecci√≥n</div>
+    <div class="row">
+      <select id="projSelect">
+        <option value="plane">Plano 2D</option>
+        <option value="360">Esfera 360¬∞ (Inmersiva)</option>
+        <option value="180">Domo 180¬∞ (Inmersiva)</option>
+      </select>
+    </div>
+
+    <div class="row" id="surfaceRow" style="display:none;">
+      <label>Superficie 360/180</label>
+      <select id="surfaceSelect" style="flex:2;">
+        <option value="sphere">Esfera</option>
+        <option value="cube">Cubo</option>
+        <option value="ovoid">Ovoide</option>
+      </select>
+    </div>
+
+    <div class="row" id="followRow" style="display:none;">
+      <label title="Mantiene la superficie centrada en el observador">Centrado en observador</label>
+      <input type="checkbox" id="followViewer" style="flex:0; width:18px; height:18px;">
+    </div>
+
+    <div id="posControls">
+      <div class="sec-head">üìè Transformaci√≥n</div>
+      <div class="row">
+        <label>Escala</label><input type="range" id="scale" min="0.01" max="20" step="0.01" value="1">
+        <span class="val" id="v_scale">1.0</span>
+      </div>
+      <div class="row">
+        <label>Modo Espejo (Flip H)</label>
+        <input type="checkbox" id="checkFlip" style="flex:0; width:18px; height:18px;">
+      </div>
+      <div class="row"><label>Distancia</label><input type="range" id="dist" min="0" max="15" step="0.1" value="2"><span class="val" id="v_dist">2.0</span></div>
+      <div class="row"><label>Altura</label><input type="range" id="height" min="-5" max="5" step="0.1" value="1.6"><span class="val" id="v_height">1.6</span></div>
+      <div class="row"><label>Rotaci√≥n Y</label><input type="range" id="rotY" min="0" max="360" step="1" value="0"><span class="val" id="v_rotY">0</span></div>
+    </div>
+
+    <div id="sphericalControls" style="display:none;">
+      <div class="sec-head">üåê Superficie Inmersiva</div>
+      <div class="row"><label>Altura Superficie</label><input type="range" id="surfaceHeight" min="-5" max="5" step="0.1" value="0"><span class="val" id="v_surfaceHeight">0.0</span></div>
+      <div class="row"><label>Offset X</label><input type="range" id="surfaceOffsetX" min="-10" max="10" step="0.1" value="0"><span class="val" id="v_surfaceOffsetX">0.0</span></div>
+      <div class="row"><label>Offset Z</label><input type="range" id="surfaceOffsetZ" min="-10" max="10" step="0.1" value="0"><span class="val" id="v_surfaceOffsetZ">0.0</span></div>
+      <div class="row"><label>Radio/Radio Base</label><input type="range" id="surfaceRadius" min="1" max="40" step="0.5" value="20"><span class="val" id="v_surfaceRadius">20.0</span></div>
+    </div>
+  </div>
+
+  <!-- üì¶ CONTROLES MODELOS 3D -->
+  <div id="modelControls" style="display:none;">
+    <div class="sec-head">üé® Renderizado 3D</div>
+    <div class="row">
+      <select id="renderMode">
+        <option value="standard">Standard (PBR)</option>
+        <option value="wireframe">Wireframe</option>
+        <option value="flat">Flat Shading</option>
+        <option value="workbench">Workbench</option>
+      </select>
+    </div>
+
+    <div class="sec-head">üß© Componentes del Modelo</div>
+    <div class="model-components" id="modelComponentsList"></div>
+
+    <div class="sec-head">üñºÔ∏è Material & Textura</div>
+    <div class="row">
+      <label>Cargar Textura</label>
+      <input type="file" id="textureInput" accept="image/*" style="flex:2; padding:6px; font-size:10px;">
+    </div>
+  </div>
+
+  <div id="mediaControls" style="display:none;">
+    <div class="sec-head">üé® Color & Imagen</div>
+    <div class="row"><label>Brillo</label><input type="range" id="brightness" min="-1" max="1" step="0.05" value="0"><span class="val" id="v_brightness">0.0</span></div>
+    <div class="row"><label>Contraste</label><input type="range" id="contrast" min="0" max="3" step="0.1" value="1"><span class="val" id="v_contrast">1.0</span></div>
+    <div class="row"><label>Saturaci√≥n</label><input type="range" id="saturation" min="0" max="3" step="0.1" value="1"><span class="val" id="v_saturation">1.0</span></div>
+    <div class="row"><label>Gamma</label><input type="range" id="gamma" min="0.1" max="3" step="0.1" value="1"><span class="val" id="v_gamma">1.0</span></div>
+
+    <div class="sec-head">üßº Anti dominante (360)</div>
+    <div class="row"><label>Anti-azulado</label><input type="range" id="deblue" min="0" max="1" step="0.01" value="0"><span class="val" id="v_deblue">0.00</span></div>
+    <div class="row"><label>Anti-verdoso</label><input type="range" id="degreen" min="0" max="1" step="0.01" value="0"><span class="val" id="v_degreen">0.00</span></div>
+
+    <div class="sec-head">üñºÔ∏è Ajuste Visual</div>
+    <div class="row"><label>Desfase X</label><input type="range" id="offsetX" min="-1" max="1" step="0.01" value="0"><span class="val" id="v_offsetX">0.0</span></div>
+    <div class="row"><label>Desfase Y</label><input type="range" id="offsetY" min="-1" max="1" step="0.01" value="0"><span class="val" id="v_offsetY">0.0</span></div>
+
+    <div class="sec-head">üü© Chroma Key Ultra (Multi-fondo)</div>
+    <div class="row">
+      <label>Activar Chroma</label>
+      <input type="checkbox" id="chromaActive" style="flex:0; width:18px; height:18px;">
+    </div>
+
+    <div id="chromaControls" style="display:none;">
+      <div style="font-size:10px; color:#888; margin-bottom:8px;">Presets r√°pidos:</div>
+      <div class="chroma-presets">
+        <div class="chroma-preset" data-color="0,1,0" style="background:#0f0;" title="Verde Croma"></div>
+        <div class="chroma-preset" data-color="0,0,1" style="background:#00f;" title="Azul Croma"></div>
+        <div class="chroma-preset" data-color="1,0,0" style="background:#f00;" title="Rojo"></div>
+        <div class="chroma-preset" data-color="0.5,0.5,0.5" style="background:#888;" title="Gris"></div>
+        <div class="chroma-preset" data-color="0,0,0" style="background:#000; border:1px solid #555;" title="Negro"></div>
+        <div class="chroma-preset" data-color="1,1,1" style="background:#fff; border:1px solid #555;" title="Blanco"></div>
+      </div>
+
+      <div class="row">
+        <label>Invertir</label>
+        <input type="checkbox" id="chromaInvert" style="flex:0; width:18px; height:18px;">
+      </div>
+
+      <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:8px; margin:8px 0; border:1px solid rgba(255,255,255,0.05);">
+        <div class="row"><label style="color:#ff7675">Rojo</label><input type="range" id="keyR" min="0" max="1" step="0.01" value="0"><span class="val" id="v_keyR">0.0</span></div>
+        <div class="row"><label style="color:#55efc4">Verde</label><input type="range" id="keyG" min="0" max="1" step="0.01" value="1"><span class="val" id="v_keyG">1.0</span></div>
+        <div class="row"><label style="color:#74b9ff">Azul</label><input type="range" id="keyB" min="0" max="1" step="0.01" value="0"><span class="val" id="v_keyB">0.0</span></div>
+        <div id="colorPrev" style="height:8px; width:100%; border-radius:4px; background:#0f0; margin-top:6px; transition:0.3s;"></div>
+      </div>
+
+      <div class="row"><label>Similitud</label><input type="range" id="sim" min="0" max="1" step="0.001" value="0.4"><span class="val" id="v_sim">0.400</span></div>
+      <div class="row"><label>Suavizado</label><input type="range" id="smooth" min="0" max="0.5" step="0.001" value="0.08"><span class="val" id="v_smooth">0.080</span></div>
+      <div class="row"><label>Despill</label><input type="range" id="despill" min="0" max="1" step="0.01" value="0.5"><span class="val" id="v_despill">0.50</span></div>
+      <div class="row"><label>Feather 360</label><input type="range" id="chromaFeather360" min="0" max="0.05" step="0.001" value="0.005"><span class="val" id="v_chromaFeather360">0.01</span></div>
+    </div>
+
+    <div class="row"><label>Opacidad</label><input type="range" id="opacity" min="0" max="1" step="0.05" value="1"><span class="val" id="v_opacity">1.0</span></div>
+
+    <div class="sec-head">üß™ Shader (estilo Unity)</div>
+    <textarea id="shaderEditor" placeholder="// Usa 'col' para modificar el color final\n// Ejemplo: col = pow(col, vec3(1.1));"></textarea>
+    <div class="row" style="gap:8px;">
+      <button class="ghost" id="loadShaderBtn">Cargar .frag/.glsl</button>
+      <button class="primary" id="applyShaderBtn">Aplicar</button>
+      <button class="warn" id="resetShaderBtn">Reset</button>
+      <input type="file" id="shaderFile" accept=".frag,.glsl" style="display:none;">
+    </div>
+
+    <div class="hint">
+      Chroma Ultra soporta: Verde, Azul, Rojo, Gris, Negro, Blanco. Usa presets o ajusta manual.
+    </div>
+  </div>
+
+  <div id="audioControls" style="display:none;">
+    <div class="sec-head">üéß Audio espacial</div>
+    <div class="audio-actions">
+      <button class="primary" id="audioPlayPause">Play/Pause</button>
+      <button class="warn" id="audioStop">Stop</button>
+    </div>
+    <div class="row"><label>Volumen</label><input type="range" id="audioVolume" min="0" max="1" step="0.01" value="1"><span class="val" id="v_audioVolume">1.00</span></div>
+    <div class="row"><label>Loop</label><input type="checkbox" id="audioLoop" style="flex:0; width:18px; height:18px;"></div>
+    <div class="row">
+      <label>Espacializaci√≥n</label>
+      <select id="audioSpace">
+        <option value="3d">3D / Posicional</option>
+        <option value="global">Global (ambiente)</option>
+      </select>
+    </div>
+    <div class="row"><label>Distancia Ref.</label><input type="range" id="audioRefDistance" min="0.1" max="10" step="0.1" value="2"><span class="val" id="v_audioRefDistance">2.0</span></div>
+    <div class="row"><label>Atenuaci√≥n</label><input type="range" id="audioRolloff" min="0" max="4" step="0.05" value="1"><span class="val" id="v_audioRolloff">1.00</span></div>
+    <div class="sec-head">üéöÔ∏è Ecualizador</div>
+    <div class="row"><label>Bajos</label><input type="range" id="audioLow" min="-15" max="15" step="0.5" value="0"><span class="val" id="v_audioLow">0.0</span></div>
+    <div class="row"><label>Medios</label><input type="range" id="audioMid" min="-15" max="15" step="0.5" value="0"><span class="val" id="v_audioMid">0.0</span></div>
+    <div class="row"><label>Altos</label><input type="range" id="audioHigh" min="-15" max="15" step="0.5" value="0"><span class="val" id="v_audioHigh">0.0</span></div>
+  </div>
+
+  <div class="btn-group" style="margin-top:20px;">
+    <button class="primary" onclick="centerActive()">üéØ Centrar</button>
+    <button class="warn" onclick="reloadVideo()">üîÑ Recargar Video</button>
+    <button class="danger" onclick="deleteActive()">üóëÔ∏è Borrar</button>
+  </div>
+
+  <div class="row" style="margin-top:20px; font-size:11px; color:#888; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
+    <label title="Oclusi√≥n de profundidad (mundo real)"><input type="checkbox" id="checkOcclusion"> Oclusi√≥n Depth API</label>
+  </div>
+
+  <div class="hint">
+    Atajos: <span class="kbd">G</span> mover, <span class="kbd">R</span> rotar, <span class="kbd">S</span> escala,
+    <span class="kbd">Supr</span> borrar. Click o VR ray para seleccionar.
+  </div>
+</div>
+
+<div class="toggle-ui" onclick="toggleUI()">üëÅÔ∏è</div>
+<button id="vrBtn">ENTRAR EN MR</button>
+
+<script type="importmap">
+  { "imports": {
+      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
+      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
+    } }
+</script>
+
+<script type="module">
+import * as THREE from 'three';
+import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
+import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
+import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
+import { TransformControls } from 'three/addons/controls/TransformControls.js';
+import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
+
+let scene, camera, renderer, xrSession, listener;
+let objects = [];
+let activeId = null;
+let transformControl, orbit;
+let grid, axes;
+let raycaster, mouse = new THREE.Vector2();
+let hoverId;
+let occlusionEnabled = false;
+let pendingXRRestart = false;
+
+const ctrl = {
+  right: { gripped: false, lastPos: new THREE.Vector3(), lastQuat: new THREE.Quaternion(), lastTrig: false, lastBtn: false },
+  left: { gripped: false },
+  gesture: { active: false, startDist: 0, startScale: 1 }
+};
+let rightRay, rayCursor;
+
+const defaultShaderSnippet = `// col es el color resultante del material
+// modifica y finaliza devolviendo col
+// ejemplo: col = pow(col, vec3(1.2));
+`;
+
+const vert = `
+varying vec2 vUv;
+uniform vec2 offset;
+void main() {
+  vUv = uv + offset;
+  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
+}`;
+
+const fragTemplate = (snippet) => `
+uniform sampler2D map;
+uniform bool chromaEnabled, chromaInvert, isEquirect;
+uniform vec3 keyColor;
+uniform float similarity, smoothness, opacity, despill;
+uniform float brightness, contrast, saturation, gamma;
+uniform float deblue, degreen, edgeFeather;
+
+varying vec2 vUv;
+
+vec3 rgb2hsv(vec3 c) {
+  vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
+  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
+  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
+  float d = q.x - min(q.w, q.y);
+  float e = 1.0e-10;
+  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
+}
+
+vec3 adjustColor(vec3 color) {
+  color += brightness;
+  color = (color - 0.5) * contrast + 0.5;
+  float gray = dot(color, vec3(0.299, 0.587, 0.114));
+  color = mix(vec3(gray), color, saturation);
+  color = pow(max(color, 0.0), vec3(1.0 / gamma));
+  return color;
+}
+
+vec3 removeBlueGray(vec3 col, float amt) {
+  if(amt <= 0.0) return col;
+  vec3 hsv = rgb2hsv(col);
+  float lowSat = 1.0 - smoothstep(0.20, 0.45, hsv.y);
+  float midVal = smoothstep(0.15, 0.95, hsv.z);
+  float hueCyan = 1.0 - smoothstep(0.20, 0.32, abs(hsv.x - 0.50));
+  float w = amt * lowSat * midVal * hueCyan;
+
+  float g = dot(col, vec3(0.299, 0.587, 0.114));
+  vec3 neutral = vec3(g);
+  vec3 outc = mix(col, neutral, w * 0.65);
+  outc.b = mix(outc.b, outc.b * (1.0 - 0.35*w), 1.0);
+  return outc;
+}
+
+vec3 removeGreenGray(vec3 col, float amt) {
+  if(amt <= 0.0) return col;
+  vec3 hsv = rgb2hsv(col);
+  float lowSat = 1.0 - smoothstep(0.20, 0.45, hsv.y);
+  float midVal = smoothstep(0.15, 0.95, hsv.z);
+  float hueGreen = 1.0 - smoothstep(0.15, 0.30, abs(hsv.x - 0.33));
+  float w = amt * lowSat * midVal * hueGreen;
+
+  float g = dot(col, vec3(0.299, 0.587, 0.114));
+  vec3 neutral = vec3(g);
+  vec3 outc = mix(col, neutral, w * 0.65);
+  outc.g = mix(outc.g, outc.g * (1.0 - 0.35*w), 1.0);
+  return outc;
+}
+
+vec3 applyCustom(vec3 col) {
+${snippet || ''}
+  return col;
+}
+
+void main() {
+  vec2 uv = isEquirect ? fract(vUv) : vUv;
+  vec4 tex = texture2D(map, uv);
+  vec3 col = tex.rgb;
+  float alpha = tex.a * opacity;
+
+  if (chromaEnabled) {
+    vec3 hsv = rgb2hsv(col);
+    vec3 kHsv = rgb2hsv(keyColor);
+
+    float hueDist = abs(hsv.x - kHsv.x);
+    if (hueDist > 0.5) hueDist = 1.0 - hueDist;
+    float satDist = abs(hsv.y - kHsv.y);
+    float valDist = abs(hsv.z - kHsv.z);
+    float rgbDist = distance(col, keyColor);
+    float isGray = 1.0 - smoothstep(0.0, 0.3, kHsv.y);
+
+    float dist = mix(
+      sqrt(pow(hueDist * 2.0, 2.0) + pow(satDist, 2.0) + pow(valDist * 0.5, 2.0)),
+      rgbDist,
+      isGray
+    );
+
+    float mask = smoothstep(similarity, similarity + smoothness, dist);
+
+    float skinProtect = 0.0;
+    if(keyColor.g > 0.7 || keyColor.b > 0.7) {
+      float skinHue = smoothstep(0.0, 0.1, hsv.x) * (1.0 - smoothstep(0.1, 0.15, hsv.x));
+      float skinSat = smoothstep(0.2, 0.6, hsv.y);
+      skinProtect = skinHue * skinSat * 3.0;
+    }
+    if(skinProtect > 0.0) mask = clamp(mask + skinProtect, 0.0, 1.0);
+
+    if (!chromaInvert) {
+      alpha *= mask;
+      if(mask < 0.95 && despill > 0.0) {
+        if(keyColor.g > keyColor.r && keyColor.g > keyColor.b) {
+          float maxRB = max(col.r, col.b);
+          col.g = mix(col.g, maxRB, (1.0 - mask) * despill);
+        } else if(keyColor.b > keyColor.g && keyColor.b > keyColor.r) {
+          float maxRG = max(col.r, col.g);
+          col.b = mix(col.b, maxRG, (1.0 - mask) * despill);
+        }
+      }
+    } else {
+      alpha *= (1.0 - mask);
+    }
+
+    if(isEquirect && edgeFeather > 0.0) {
+      vec3 blur = 0.333 * (
+        texture2D(map, fract(uv + vec2(edgeFeather, 0.0))).rgb +
+        texture2D(map, fract(uv - vec2(edgeFeather, 0.0))).rgb +
+        col
+      );
+      col = mix(col, blur, 0.5);
+    }
+  }
+
+  col = removeBlueGray(col, deblue);
+  col = removeGreenGray(col, degreen);
+  col = adjustColor(col);
+  col = applyCustom(col);
+
+  gl_FragColor = vec4(col, alpha);
+  if (alpha < 0.01) discard;
+}
+`;
+
+function init() {
+  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), alpha: true, antialias: true });
+  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
+  renderer.setSize(window.innerWidth, window.innerHeight);
+  renderer.xr.enabled = true;
+  renderer.xr.setReferenceSpaceType('local-floor');
+
+  scene = new THREE.Scene();
+  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 2000);
+  camera.position.set(0, 1.6, 3);
+  listener = new THREE.AudioListener();
+  camera.add(listener);
+
+  scene.add(new THREE.AmbientLight(0xffffff, 1.2));
+  const d = new THREE.DirectionalLight(0xffffff, 1.5);
+  d.position.set(2, 5, 2);
+  scene.add(d);
+
+  grid = new THREE.GridHelper(30, 60, 0x6c5ce7, 0x333333);
+  grid.position.y = 0;
+  scene.add(grid);
+
+  axes = new THREE.AxesHelper(2);
+  axes.position.set(0, 0.01, 0);
+  scene.add(axes);
+
+  orbit = new OrbitControls(camera, renderer.domElement);
+  orbit.enableDamping = true;
+  orbit.dampingFactor = 0.06;
+  orbit.target.set(0, 1.6, 0);
+  orbit.update();
+
+  transformControl = new TransformControls(camera, renderer.domElement);
+  transformControl.setSize(1.2);
+  transformControl.addEventListener('dragging-changed', e=>{
+    orbit.enabled = !e.value;
+  });
+  transformControl.addEventListener('objectChange', syncFromTransform);
+  transformControl.setTranslationSnap(null);
+  transformControl.setRotationSnap(null);
+  transformControl.setScaleSnap(null);
+  scene.add(transformControl);
+
+  setupVR();
+  initRay();
+  initMousePick();
+  initShortcuts();
+  initVideoControls();
+  initChromaPresets();
+  initLayerDragDrop();
+  initShaderControls();
+  initAudioControls();
+
+  document.getElementById('checkGrid').addEventListener('change', e=>grid.visible=e.target.checked);
+  document.getElementById('checkAxes').addEventListener('change', e=>axes.visible=e.target.checked);
+  document.getElementById('checkGizmo').addEventListener('change', e=>transformControl.visible=e.target.checked);
+  document.getElementById('checkSnap').addEventListener('change', e=>{
+    transformControl.setTranslationSnap(e.target.checked ? 0.25 : null);
+  });
+
+  document.getElementById('chromaActive').addEventListener('change', e=>{
+    document.getElementById('chromaControls').style.display = e.target.checked ? 'block' : 'none';
+  });
+
+  document.getElementById('checkOcclusion').addEventListener('change', handleOcclusionToggle);
+
+  document.getElementById('renderMode').addEventListener('change', e=>{
+    const o = objects.find(x=>x.id===activeId);
+    if(o && o.type==='model') applyRenderMode(o, e.target.value);
+  });
+
+  document.getElementById('textureInput').addEventListener('change', async e=>{
+    if(!e.target.files.length) return;
+    const o = objects.find(x=>x.id===activeId);
+    if(!o || o.type!=='model') return;
+    const tex = await new THREE.TextureLoader().loadAsync(URL.createObjectURL(e.target.files[0]));
+    tex.colorSpace = THREE.SRGBColorSpace;
+    o.mesh.traverse(c=>{
+      if(c.isMesh && c.material) {
+        if(Array.isArray(c.material)) c.material.forEach(m=>m.map=tex);
+        else c.material.map = tex;
+      }
+    });
+  });
+
+  window.addEventListener('resize', onResize);
+  renderer.setAnimationLoop(render);
+
+  document.getElementById('exitXrBtn').onclick = ()=>{ if(xrSession) xrSession.end(); };
+  setMode(false);
+}
+
+function onResize() {
+  camera.aspect = window.innerWidth/window.innerHeight;
+  camera.updateProjectionMatrix();
+  renderer.setSize(window.innerWidth, window.innerHeight);
+}
+
+function setMode(isXR){
+  const dot = document.getElementById('modeDot');
+  const text = document.getElementById('modeText');
+  const exitBtn = document.getElementById('exitXrBtn');
+
+  if(isXR){
+    dot.style.background = '#ff7675';
+    dot.style.boxShadow = '0 0 18px rgba(255,118,117,0.7)';
+    text.innerText = 'MODO MR (PREVIEW)';
+    exitBtn.style.display = 'inline-block';
+    orbit.enabled = false;
+    grid.visible = false;
+    axes.visible = false;
+  } else {
+    dot.style.background = '#55efc4';
+    dot.style.boxShadow = '0 0 18px rgba(85,239,196,0.6)';
+    text.innerText = 'MODO EDITOR';
+    exitBtn.style.display = 'none';
+    orbit.enabled = true;
+    grid.visible = document.getElementById('checkGrid').checked;
+    axes.visible = document.getElementById('checkAxes').checked;
+  }
+}
+
+// ======= VIDEO CONTROLS =======
+function initVideoControls() {
+  let activeVideo = null;
+
+  const updateControls = () => {
+    const o = objects.find(x=>x.id===activeId);
+    const vidCtrl = document.getElementById('videoControls');
+
+    if(o && o.video) {
+      activeVideo = o.video;
+      vidCtrl.classList.add('show');
+
+      const btn = document.getElementById('vidPlayPause');
+      btn.innerHTML = activeVideo.paused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
+
+      document.getElementById('vidVolume').value = activeVideo.volume;
+      document.getElementById('v_vidVolume').innerText = Math.round(activeVideo.volume * 100);
+    } else {
+      activeVideo = null;
+      vidCtrl.classList.remove('show');
+    }
+  };
+
+  document.getElementById('vidPlayPause').onclick = () => {
+    if(!activeVideo) return;
+    if(activeVideo.paused) activeVideo.play();
+    else activeVideo.pause();
+    updateControls();
+  };
+
+  document.getElementById('vidStop').onclick = () => {
+    if(!activeVideo) return;
+    activeVideo.pause();
+    activeVideo.currentTime = 0;
+    updateControls();
+  };
+
+  document.getElementById('vidProgress').onclick = (e) => {
+    if(!activeVideo) return;
+    const rect = e.currentTarget.getBoundingClientRect();
+    const x = e.clientX - rect.left;
+    const pct = x / rect.width;
+    activeVideo.currentTime = pct * activeVideo.duration;
+  };
+
+  document.getElementById('vidVolume').oninput = (e) => {
+    if(!activeVideo) return;
+    activeVideo.volume = parseFloat(e.target.value);
+    document.getElementById('v_vidVolume').innerText = Math.round(activeVideo.volume * 100);
+  };
+
+  setInterval(() => {
+    if(!activeVideo || activeVideo.paused) return;
+    const pct = (activeVideo.currentTime / activeVideo.duration) * 100;
+    document.getElementById('vidProgressBar').style.width = pct + '%';
+
+    const fmt = (s) => {
+      const m = Math.floor(s/60);
+      const sec = Math.floor(s%60);
+      return `${m}:${sec.toString().padStart(2,'0')}`;
+    };
+    document.getElementById('vidTime').innerText =
+      `${fmt(activeVideo.currentTime)} / ${fmt(activeVideo.duration)}`;
+  }, 100);
+
+  window.addEventListener('activeObjChanged', updateControls);
+}
+
+// ======= CHROMA PRESETS =======
+function initChromaPresets() {
+  document.querySelectorAll('.chroma-preset').forEach(el=>{
+    el.onclick = () => {
+      const [r,g,b] = el.dataset.color.split(',').map(Number);
+      updateObj('keyR', r);
+      updateObj('keyG', g);
+      updateObj('keyB', b);
+      syncUI();
+
+      document.querySelectorAll('.chroma-preset').forEach(e=>e.classList.remove('active'));
+      el.classList.add('active');
+    };
+  });
+}
+
+// ======= DRAG & DROP LAYERS =======
+function initLayerDragDrop() {
+  let draggedId = null;
+
+  window.addEventListener('layerListUpdated', ()=>{
+    document.querySelectorAll('.layer-item').forEach(el=>{
+      el.draggable = true;
+
+      el.ondragstart = (e) => {
+        draggedId = el.dataset.id;
+        el.classList.add('dragging');
+      };
+
+      el.ondragend = () => {
+        el.classList.remove('dragging');
+        draggedId = null;
+      };
+
+      el.ondragover = (e) => {
+        e.preventDefault();
+        const afterElement = getDragAfterElement(e.clientY);
+        const dragging = document.querySelector('.dragging');
+        if(afterElement == null) {
+          document.getElementById('layerList').appendChild(dragging);
+        } else {
+          document.getElementById('layerList').insertBefore(dragging, afterElement);
+        }
+      };
+
+      el.ondrop = (e) => {
+        e.preventDefault();
+        if(!draggedId) return;
+
+        const items = [...document.querySelectorAll('.layer-item')];
+        const newOrder = items.map(item=>item.dataset.id);
+
+        const newObjects = [];
+        newOrder.forEach(id=>{
+          const obj = objects.find(o=>o.id===id);
+          if(obj) newObjects.push(obj);
+        });
+
+        objects = newObjects;
+        updateRenderOrder();
+      };
+    });
+  });
+}
+
+function getDragAfterElement(y) {
+  const draggableElements = [...document.querySelectorAll('.layer-item:not(.dragging)')];
+  return draggableElements.reduce((closest, child) => {
+    const box = child.getBoundingClientRect();
+    const offset = y - box.top - box.height / 2;
+    if (offset < 0 && offset > closest.offset) {
+      return { offset: offset, element: child };
+    } else {
+      return closest;
+    }
+  }, { offset: Number.NEGATIVE_INFINITY }).element;
+}
+
+function updateRenderOrder() {
+  objects.forEach((o, i) => {
+    if(o.mesh) o.mesh.renderOrder = i;
+  });
+}
+
+// ======= 3D MODEL COMPONENTS =======
+function populateModelComponents(obj) {
+  const list = document.getElementById('modelComponentsList');
+  list.innerHTML = '';
+
+  const components = [];
+  obj.mesh.traverse(child => {
+    if(child.isMesh || child.isLight) {
+      components.push({
+        name: child.name || child.type,
+        obj: child,
+        type: child.isLight ? 'üí°' : 'üì¶'
+      });
+    }
+  });
+
+  if(components.length === 0) {
+    list.innerHTML = '<div style="color:#888; font-size:10px; padding:8px;">Sin componentes</div>';
+    return;
+  }
+
+  components.forEach(comp => {
+    const item = document.createElement('div');
+    item.className = 'model-comp-item';
+    item.innerHTML = `
+      <input type="checkbox" checked data-compname="${comp.name}">
+      <label>${comp.type} ${comp.name}</label>
+    `;
+
+    item.querySelector('input').onchange = (e) => {
+      comp.obj.visible = e.target.checked;
+    };
+
+    list.appendChild(item);
+  });
+}
+
+function applyRenderMode(obj, mode) {
+  obj.renderMode = mode;
+  obj.mesh.traverse(child => {
+    if(!child.isMesh) return;
+
+    const mats = Array.isArray(child.material) ? child.material : [child.material];
+
+    mats.forEach(mat => {
+      switch(mode) {
+        case 'wireframe':
+          mat.wireframe = true;
+          mat.flatShading = false;
+          break;
+        case 'flat':
+          mat.wireframe = false;
+          mat.flatShading = true;
+          mat.needsUpdate = true;
+          break;
+        case 'workbench':
+          mat.wireframe = false;
+          mat.flatShading = true;
+          mat.color.setHex(0xcccccc);
+          mat.roughness = 0.8;
+          mat.metalness = 0.1;
+          mat.needsUpdate = true;
+          break;
+        default:
+          mat.wireframe = false;
+          mat.flatShading = false;
+          mat.needsUpdate = true;
+      }
+    });
+  });
+}
+
+// ======= INPUT / IMPORT =======
+document.getElementById('fileInput').addEventListener('change', async e => {
+  if(!e.target.files.length) return;
+  toggleLoader(true);
+  for(const f of e.target.files) {
+    try {
+      const url = URL.createObjectURL(f);
+      const n = f.name.toLowerCase();
+      if(n.match(/\.(glb|gltf)$/)) await load3D(url, n, 'gltf');
+      else if(n.match(/\.fbx$/)) await load3D(url, n, 'fbx');
+      else if(n.match(/\.obj$/)) await load3D(url, n, 'obj');
+      else if(n.match(/\.gif$/)) await loadGif(f, n);
+      else if(f.type.startsWith('video/') || n.includes('360') || n.includes('180')) await loadVideo(url, n);
+      else if(f.type.startsWith('audio/')) await loadAudio(url, n);
+      else if(n.match(/\.(frag|glsl)$/)) await loadShaderFile(f);
+      else if(f.type.startsWith('image/')) await loadImg(url, n);
+    } catch(err) {
+      console.error('Error al cargar archivo:', f.name, err);
+    }
+  }
+  toggleLoader(false);
+  e.target.value = '';
+});
+
+async function loadShaderFile(file) {
+  const txt = await file.text();
+  const editor = document.getElementById('shaderEditor');
+  editor.value = txt;
+  applyShaderSnippet();
+}
+
+async function loadAudio(url, name) {
+  const loader = new THREE.AudioLoader();
+  const buffer = await loader.loadAsync(url);
+  const audio = new THREE.PositionalAudio(listener);
+  audio.setBuffer(buffer);
+  audio.setLoop(true);
+  audio.setVolume(1);
+
+  const filters = createEQFilters(audio.context);
+  audio.setFilters(filters);
+
+  const mesh = new THREE.Mesh(
+    new THREE.SphereGeometry(0.12),
+    new THREE.MeshStandardMaterial({ color: 0xffc300, emissive: 0x332200, roughness: 0.25, metalness: 0.05 })
+  );
+  mesh.position.set(0, 1.5, -1.5);
+  mesh.add(audio);
+
+  const obj = {
+    id: uid(),
+    mesh,
+    name,
+    type:'audio',
+    audio,
+    filters,
+    settings: {
+      ...defSettings(),
+      audioVolume:1, audioLoop:true, audioSpace:'3d',
+      audioRefDistance:2, audioRolloff:1,
+      audioLow:0, audioMid:0, audioHigh:0
+    }
+  };
+  addObj(obj);
+}
+
+function createEQFilters(ctx) {
+  const low = ctx.createBiquadFilter();
+  low.type = 'lowshelf'; low.frequency.value = 120;
+  const mid = ctx.createBiquadFilter();
+  mid.type = 'peaking'; mid.frequency.value = 1000; mid.Q.value = 1;
+  const high = ctx.createBiquadFilter();
+  high.type = 'highshelf'; high.frequency.value = 8000;
+  low.gain.value = mid.gain.value = high.gain.value = 0;
+  low.connect(mid); mid.connect(high);
+  return [low, mid, high];
+}
+
+async function loadVideo(url, name) {
+  const vid = document.createElement('video');
+  vid.src = url;
+  vid.crossOrigin = 'anonymous';
+  vid.loop = true;
+  vid.muted = false;
+  vid.playsInline = true;
+  vid.style.display = 'none';
+  document.body.appendChild(vid);
+
+  await new Promise(resolve => {
+    vid.onloadedmetadata = () => resolve();
+    vid.play().catch(e=>console.log("Autoplay prevent:", e));
+  });
+
+  const tex = new THREE.VideoTexture(vid);
+  tex.colorSpace = THREE.SRGBColorSpace;
+  tex.wrapS = THREE.RepeatWrapping;
+  tex.wrapT = THREE.RepeatWrapping;
+  tex.minFilter = THREE.LinearFilter;
+  tex.magFilter = THREE.LinearFilter;
+
+  let proj = 'plane';
+  if(name.includes('360')) proj='360';
+  else if(name.includes('180')) proj='180';
+
+  const ar = (vid.videoWidth && vid.videoHeight) ? vid.videoWidth/vid.videoHeight : 1.77;
+
+  const mesh = createMesh(proj, 'sphere', tex, ar, defSettings());
+  const obj = { id: uid(), mesh, name, type:'video', video:vid, tex, settings: { ...defSettings(), projection:proj } };
+
+  if(proj !== 'plane') {
+    obj.mesh.position.set(0, 0, 0);
+    obj.settings.scale = 1;
+    obj.settings.dist = 0;
+  } else {
+    obj.mesh.position.set(0, 1.6, -2);
+    obj.settings.dist = 2;
+  }
+
+  addObj(obj);
+}
+
+async function loadGif(file, name) {
+  const buf = await file.arrayBuffer();
+  let R = window.GifReader || (window.Omggif ? window.Omggif.GifReader : null);
+  if(!R) return;
+  const r = new R(new Uint8Array(buf));
+  const w=r.width, h=r.height;
+  const cvs=document.createElement('canvas');
+  cvs.width=w; cvs.height=h;
+  const ctx=cvs.getContext('2d');
+  const dat=ctx.createImageData(w,h);
+  const tex=new THREE.CanvasTexture(cvs);
+  tex.colorSpace=THREE.SRGBColorSpace;
+  tex.wrapS = THREE.RepeatWrapping;
+  tex.wrapT = THREE.RepeatWrapping;
+
+  const mesh = createMesh('plane', 'sphere', tex, w/h, defSettings());
+  mesh.position.set(0, 1.6, -2);
+  const obj = { id:uid(), mesh, name, type:'gif', settings:defSettings(), gif:{r,ctx,dat,tex,f:0,num:r.numFrames(),t:0} };
+  addObj(obj);
+}
+
+async function loadImg(url, name) {
+  const tex = await new THREE.TextureLoader().loadAsync(url);
+  tex.colorSpace = THREE.SRGBColorSpace;
+  tex.wrapS = THREE.RepeatWrapping;
+  tex.wrapT = THREE.RepeatWrapping;
+  const mesh = createMesh('plane', 'sphere', tex, tex.image.width/tex.image.height, defSettings());
+  mesh.position.set(0, 1.6, -2);
+  const obj = { id:uid(), mesh, name, type:'image', tex, settings:defSettings() };
+  addObj(obj);
+}
+
+async function load3D(url, name, type) {
+  let m;
+  if(type==='gltf') m=(await new GLTFLoader().loadAsync(url)).scene;
+  else if(type==='fbx') m=await new FBXLoader().loadAsync(url);
+  else m=await new OBJLoader().loadAsync(url);
+
+  const box = new THREE.Box3().setFromObject(m);
+  const sz = box.getSize(new THREE.Vector3()).length();
+  const sc = (sz>0 && sz<1000) ? 2/sz : 1;
+  m.scale.setScalar(sc);
+  m.position.set(0, 1, -2);
+
+  m.traverse(c=>{
+    if(c.isMesh) {
+      if(!c.material.transparent) c.material.transparent = true;
+      c.material.depthWrite = true;
+      c.castShadow = true;
+    }
+  });
+
+  const obj = {
+    id:uid(),
+    mesh:m,
+    name,
+    type:'model',
+    settings:defSettings(),
+    renderMode: 'standard'
+  };
+  obj.baseScale = sc;
+  addObj(obj);
+}
+
+// ======= GEOMETR√çAS / SUPERFICIES =======
+function buildChromaMaterial(tex, isEquirect, settings) {
+  const frag = fragTemplate(settings.shaderSnippet || defaultShaderSnippet);
+  return new THREE.ShaderMaterial({
+    uniforms: {
+      map: { value: tex },
+      chromaEnabled:{value:false},
+      chromaInvert:{value:false},
+      keyColor:{value:new THREE.Color(0,1,0)},
+      similarity:{value:0.4},
+      smoothness:{value:0.08},
+      despill:{value:0.5},
+      offset:{value:new THREE.Vector2(0,0)},
+      opacity:{value:1.0},
+      brightness:{value:0.0},
+      contrast:{value:1.0},
+      saturation:{value:1.0},
+      gamma:{value:1.0},
+      deblue:{value:0.0},
+      degreen:{value:0.0},
+      isEquirect:{value:isEquirect},
+      edgeFeather:{value:settings.chromaFeather360 || 0.005}
+    },
+    vertexShader: vert,
+    fragmentShader: frag,
+    transparent: true,
+    side: isEquirect ? THREE.BackSide : THREE.DoubleSide,
+    depthWrite: (settings.projection==='plane'),
+    depthTest: true
+  });
+}
+
+function createMesh(proj, surface, tex, aspect, settings) {
+  let geo, side=THREE.DoubleSide;
+  const radius = settings.surfaceRadius || 20;
+  const makeInside = (g)=>{ g.computeVertexNormals(); return g; };
+
+  if(proj === '360') {
+    side = THREE.BackSide;
+    if(surface === 'cube'){
+      geo = makeInside(new THREE.BoxGeometry(radius*2, radius*2, radius*2, 1, 1, 1));
+    } else {
+      geo = makeInside(new THREE.SphereGeometry(radius, 64, 64));
+      if(surface === 'ovoid') geo.scale(1.25, 1.0, 1.0);
+    }
+  } else if(proj === '180') {
+    side = THREE.BackSide;
+    geo = makeInside(new THREE.SphereGeometry(radius, 64, 64, 0, Math.PI));
+    if(surface === 'ovoid') geo.scale(1.25, 1.0, 1.0);
+    geo.rotateY(-Math.PI/2);
+  } else {
+    geo = new THREE.PlaneGeometry(aspect, 1);
+  }
+
+  const mat = buildChromaMaterial(tex, proj!=='plane', settings);
+  const mesh = new THREE.Mesh(geo, mat);
+  if(proj !== 'plane') {
+    mesh.frustumCulled = false;
+    mesh.renderOrder = -1;
+  }
+  return mesh;
+}
+
+function defSettings() {
+  return {
+    scale:1, dist:2, height:1.6, rotY:0, projection:'plane',
+    surface:'sphere', followViewer:false,
+    surfaceRadius:20, surfaceHeight:0, surfaceOffsetX:0, surfaceOffsetZ:0,
+    flipX:false,
+    chromaEnabled:false, chromaInvert:false,
+    keyR:0, keyG:1, keyB:0,
+    sim:0.4, smooth:0.08, despill:0.5,
+    chromaFeather360:0.005,
+    offsetX:0, offsetY:0, opac:1,
+    brightness:0, contrast:1, saturation:1, gamma:1,
+    deblue:0, degreen:0,
+    shaderSnippet: defaultShaderSnippet
+  };
+}
+
+function uid() { return Math.random().toString(36).substr(2,9); }
+
+function addObj(obj) {
+  scene.add(obj.mesh);
+  objects.push(obj);
+  updateRenderOrder();
+  updateList();
+  selectObj(obj.id);
+}
+
+// ======= UPDATE OBJ / UI =======
+function updateObj(k, v) {
+  const o = objects.find(x=>x.id===activeId);
+  if(!o) return;
+
+  if(o.type === 'audio') {
+    applyAudioSetting(o, k, v);
+    syncUI();
+    return;
+  }
+
+  o.settings[k]=v;
+  const s = o.settings;
+  const m = o.mesh;
+
+  if(k==='projection' || k==='surface' || k==='surfaceRadius') {
+    if(o.type==='model') return;
+
+    scene.remove(m);
+    let ar=1.77;
+    if(o.video) ar=o.video.videoWidth/o.video.videoHeight;
+    else if(o.tex && o.tex.image) ar=o.tex.image.width/o.tex.image.height;
+
+    const tex = o.tex || m.material.uniforms?.map.value;
+    const nm = createMesh(s.projection, s.surface, tex, ar, s);
+    nm.rotation.copy(m.rotation);
+    nm.position.copy(m.position);
+    nm.scale.copy(m.scale);
+
+    o.mesh = nm;
+    applyUniforms(o);
+
+    if(s.projection!=='plane'){
+      nm.position.set(s.surfaceOffsetX, s.surfaceHeight, s.surfaceOffsetZ);
+      o.settings.dist = 0;
+    } else {
+      if(Math.abs(o.settings.dist) < 0.01) o.settings.dist = 2;
+      nm.position.set(0, o.settings.height, -o.settings.dist);
+    }
+
+    scene.add(nm);
+    selectObj(o.id);
+    return;
+  }
+
+  if(k==='scale' || k==='flipX' || k==='surfaceRadius') {
+    const bs = o.baseScale || 1;
+    const dir = s.flipX ? -1 : 1;
+    const radiusFactor = (s.surfaceRadius || 20) / 20;
+    m.scale.set(s.scale * bs * dir * radiusFactor, s.scale * bs * radiusFactor, s.scale * bs * radiusFactor);
+  }
+
+  if(s.projection==='plane' || o.type==='model') {
+    if(k==='dist') m.position.z = -s.dist;
+    if(k==='height') m.position.y = s.height;
+  } else {
+    m.position.set(s.surfaceOffsetX, s.surfaceHeight, s.surfaceOffsetZ);
+  }
+
+  if(k==='surfaceHeight' || k==='surfaceOffsetX' || k==='surfaceOffsetZ') {
+    if(s.projection==='plane' || o.type==='model') return;
+    m.position.set(s.surfaceOffsetX, s.surfaceHeight, s.surfaceOffsetZ);
+  }
+
+  if(k==='rotY') m.rotation.y = THREE.MathUtils.degToRad(s.rotY) + (s.projection==='180'?-Math.PI/2:0);
+
+  if(k==='shaderSnippet') {
+    if(o.type !== 'model') {
+      const tex = o.tex || m.material.uniforms?.map.value;
+      const mat = buildChromaMaterial(tex, s.projection!=='plane', s);
+      m.material.dispose();
+      m.material = mat;
+    }
+  }
+
+  if(o.type !== 'model' && m.material.uniforms) {
+    applyUniforms(o);
+  }
+}
+
+function applyUniforms(o){
+  const s=o.settings;
+  const m=o.mesh;
+  if(o.type === 'model') return;
+  if(!m.material?.uniforms) return;
+  const u=m.material.uniforms;
+  u.chromaEnabled.value=s.chromaEnabled;
+  u.chromaInvert.value=s.chromaInvert;
+  u.keyColor.value.setRGB(s.keyR, s.keyG, s.keyB);
+  u.similarity.value=s.sim;
+  u.smoothness.value=s.smooth;
+  u.despill.value=s.despill;
+  u.offset.value.set(s.offsetX, s.offsetY);
+  u.opacity.value=s.opac;
+
+  u.brightness.value=s.brightness;
+  u.contrast.value=s.contrast;
+  u.saturation.value=s.saturation;
+  u.gamma.value=s.gamma;
+
+  u.deblue.value=s.deblue;
+  u.degreen.value=s.degreen;
+  if(u.isEquirect) u.isEquirect.value = (s.projection==='360'||s.projection==='180');
+  if(u.edgeFeather) u.edgeFeather.value = s.chromaFeather360 || 0.005;
+}
+
+const bind = (id, k, type='float') => {
+  document.getElementById(id).addEventListener('input', e=>{
+    let v=e.target.value;
+    if(type==='float') v=parseFloat(v);
+    else if(type==='bool') v=e.target.checked;
+    updateObj(k,v);
+    syncUI();
+  });
+};
+
+bind('projSelect','projection','str');
+bind('surfaceSelect','surface','str');
+bind('followViewer','followViewer','bool');
+
+bind('scale','scale');
+bind('dist','dist');
+bind('height','height');
+bind('rotY','rotY');
+
+bind('surfaceHeight','surfaceHeight');
+bind('surfaceOffsetX','surfaceOffsetX');
+bind('surfaceOffsetZ','surfaceOffsetZ');
+bind('surfaceRadius','surfaceRadius');
+
+bind('chromaActive','chromaEnabled','bool');
+bind('chromaInvert','chromaInvert','bool');
+bind('keyR','keyR');
+bind('keyG','keyG');
+bind('keyB','keyB');
+bind('sim','sim');
+bind('smooth','smooth');
+bind('despill','despill');
+bind('offsetX','offsetX');
+bind('offsetY','offsetY');
+bind('opacity','opac');
+bind('brightness','brightness');
+bind('contrast','contrast');
+bind('saturation','saturation');
+bind('gamma','gamma');
+bind('deblue','deblue');
+bind('degreen','degreen');
+bind('chromaFeather360','chromaFeather360');
+
+bind('checkFlip', 'flipX', 'bool');
+
+// Audio bindings
+const bindAudio = (id, key, type='float') => {
+  document.getElementById(id).addEventListener('input', e=>{
+    let v=e.target.value;
+    if(type==='float') v=parseFloat(v);
+    else if(type==='bool') v=e.target.checked;
+    else if(type==='str') v=e.target.value;
+    updateObj(key, v);
+    syncUI();
+  });
+};
+bindAudio('audioVolume','audioVolume');
+bindAudio('audioLoop','audioLoop','bool');
+bindAudio('audioSpace','audioSpace','str');
+bindAudio('audioRefDistance','audioRefDistance');
+bindAudio('audioRolloff','audioRolloff');
+bindAudio('audioLow','audioLow');
+bindAudio('audioMid','audioMid');
+bindAudio('audioHigh','audioHigh');
+
+function selectObj(id) {
+  activeId = id;
+  const o = objects.find(x=>x.id===id);
+
+  if(o) {
+    const isMedia = (o.type !== 'model' && o.type !== 'audio');
+    const is3D = (o.type === 'model');
+    const isAudio = (o.type === 'audio');
+
+    if(isAudio || o.settings.projection !== 'plane' || is3D) {
+      transformControl.attach(o.mesh);
+    } else {
+      transformControl.attach(o.mesh);
+    }
+
+    document.getElementById('mediaControls').style.display = isMedia ? 'block' : 'none';
+    document.getElementById('modelControls').style.display = is3D ? 'block' : 'none';
+    document.getElementById('audioControls').style.display = isAudio ? 'block' : 'none';
+    document.getElementById('generalControls').style.display = isAudio ? 'none' : 'block';
+
+    if(is3D) {
+      populateModelComponents(o);
+      document.getElementById('renderMode').value = o.renderMode || 'standard';
+    }
+
+    syncUI();
+    window.dispatchEvent(new Event('activeObjChanged'));
+  } else {
+    transformControl.detach();
+    document.getElementById('mediaControls').style.display = 'none';
+    document.getElementById('modelControls').style.display = 'none';
+    document.getElementById('audioControls').style.display = 'none';
+  }
+  updateList();
+}
+
+function syncUI() {
+  const o = objects.find(x=>x.id===activeId);
+  if(!o) return;
+  const s = o.settings;
+
+  const set = (id, v) => {
+    const el=document.getElementById(id);
+    if(el) {
+      if(el.type === 'checkbox') el.checked = !!v;
+      else el.value=v;
+    }
+    const t=document.getElementById('v_'+id);
+    if(t) {
+      if(typeof v==='number') {
+        if(id==='sim' || id==='smooth' || id==='despill' || id.includes('chroma') || id.startsWith('audio')) t.innerText=v.toFixed(3);
+        else t.innerText=v.toFixed(2);
+      } else {
+        t.innerText = v;
+      }
+    }
+  };
+
+  if(o.type!=='model' && o.type!=='audio') document.getElementById('projSelect').value = s.projection;
+
+  const is360 = (s.projection === '360' || s.projection === '180');
+  document.getElementById('posControls').style.display = (!is360 && o.type!=='audio') ? 'block' : 'none';
+  document.getElementById('sphericalControls').style.display = (is360 && o.type!=='audio') ? 'block' : 'none';
+
+  document.getElementById('surfaceRow').style.display = (is360 && o.type!=='audio') ? 'flex' : 'none';
+  document.getElementById('followRow').style.display = (is360 && o.type!=='audio') ? 'flex' : 'none';
+  if(is360){
+    document.getElementById('surfaceSelect').value = s.surface || 'sphere';
+    document.getElementById('followViewer').checked = !!s.followViewer;
+    set('surfaceHeight', s.surfaceHeight);
+    set('surfaceOffsetX', s.surfaceOffsetX);
+    set('surfaceOffsetZ', s.surfaceOffsetZ);
+    set('surfaceRadius', s.surfaceRadius);
+  }
+
+  if(!is360 && o.type!=='audio') {
+    set('dist',Math.abs(o.mesh.position.z));
+    set('height',o.mesh.position.y);
+  }
+
+  if(o.type!=='audio') {
+    set('scale',s.scale);
+    set('rotY',s.rotY);
+    document.getElementById('checkFlip').checked = s.flipX;
+  }
+
+  if(o.type !== 'model' && o.type !== 'audio' && o.mesh.material.uniforms) {
+    document.getElementById('chromaActive').checked = s.chromaEnabled;
+    document.getElementById('chromaControls').style.display = s.chromaEnabled ? 'block' : 'none';
+    document.getElementById('chromaInvert').checked = s.chromaInvert;
+    set('keyR',s.keyR);
+    set('keyG',s.keyG);
+    set('keyB',s.keyB);
+    document.getElementById('colorPrev').style.background = `rgb(${s.keyR*255},${s.keyG*255},${s.keyB*255})`;
+    set('sim',s.sim);
+    set('smooth',s.smooth);
+    set('despill',s.despill);
+    set('offsetX',s.offsetX);
+    set('offsetY',s.offsetY);
+    set('opacity',s.opac);
+    set('brightness',s.brightness);
+    set('contrast',s.contrast);
+    set('saturation',s.saturation);
+    set('gamma',s.gamma);
+    set('deblue', s.deblue);
+    set('degreen', s.degreen);
+    set('chromaFeather360', s.chromaFeather360 || 0.005);
+    document.getElementById('shaderEditor').value = s.shaderSnippet || defaultShaderSnippet;
+  }
+
+  if(o.type === 'audio') {
+    set('audioVolume', s.audioVolume ?? 1);
+    document.getElementById('audioLoop').checked = s.audioLoop ?? true;
+    document.getElementById('audioSpace').value = s.audioSpace || '3d';
+    set('audioRefDistance', s.audioRefDistance ?? 2);
+    set('audioRolloff', s.audioRolloff ?? 1);
+    set('audioLow', s.audioLow ?? 0);
+    set('audioMid', s.audioMid ?? 0);
+    set('audioHigh', s.audioHigh ?? 0);
+  }
+}
+
+window.centerActive = () => {
+  const o=objects.find(x=>x.id===activeId);
+  if(!o) return;
+  if(o.type==='audio') {
+    o.mesh.position.set(0,1.6,-1.5);
+    syncUI();
+    return;
+  }
+  if(o.settings.projection==='plane' || o.type==='model'){
+    o.mesh.position.set(0,1.6,-2);
+    o.mesh.rotation.set(0,0,0);
+    o.settings.dist=2;
+    o.settings.height=1.6;
+    o.settings.rotY=0;
+    syncUI();
+  } else {
+    o.mesh.position.set(0,0,0);
+    o.settings.surfaceOffsetX = 0;
+    o.settings.surfaceOffsetZ = 0;
+    o.settings.surfaceHeight = 0;
+    o.settings.rotY = 0;
+    syncUI();
+  }
+};
+
+window.reloadVideo = () => {
+  const o=objects.find(x=>x.id===activeId);
+  if(o && o.video) {
+    o.video.pause();
+    o.video.currentTime=0;
+    o.video.play().catch(e=>console.log(e));
+  }
+};
+
+window.deleteActive = () => {
+  const i = objects.findIndex(x=>x.id===activeId);
+  if(i>-1) {
+    const o=objects[i];
+    scene.remove(o.mesh);
+    if(o.video){
+      o.video.pause();
+      o.video.remove();
+    }
+    if(o.mesh.geometry) o.mesh.geometry.dispose();
+    if(o.mesh.material?.dispose) o.mesh.material.dispose();
+    objects.splice(i,1);
+    activeId=null;
+    selectObj(null);
+    updateRenderOrder();
+  }
+};
+
+function updateList() {
+  const l=document.getElementById('layerList');
+  l.innerHTML='';
+  objects.forEach(o=>{
+    const d=document.createElement('div');
+    d.className=`layer-item ${o.id===activeId?'active':''}`;
+    d.dataset.id = o.id;
+    const icon = o.type==='model'?'üì¶':(o.type==='audio'?'üéß':(o.settings.projection==='360'||o.settings.projection==='180'?'üåê':'üé¨'));
+    d.innerHTML=`
+      <span>${icon}</span>
+      <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${o.name}</span>
+    `;
+    d.onclick=()=>selectObj(o.id);
+    l.appendChild(d);
+  });
+  window.dispatchEvent(new Event('layerListUpdated'));
+}
+
+window.toggleUI=()=>document.getElementById('ui').classList.toggle('hidden');
+
+function toggleLoader(s){
+  document.getElementById('loader').style.display=s?'flex':'none';
+}
+
+// ======= Mouse picking =======
+function initMousePick(){
+  raycaster = new THREE.Raycaster();
+  renderer.domElement.addEventListener('pointerdown', (ev)=>{
+    if(xrSession) return;
+    if(transformControl.dragging) return;
+
+    const rect = renderer.domElement.getBoundingClientRect();
+    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
+    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
+
+    const targets = objects.map(o=>o.mesh);
+
+    raycaster.setFromCamera(mouse, camera);
+    const hits = raycaster.intersectObjects(targets, true);
+    if(hits.length){
+      let m = hits[0].object;
+      const found = objects.find(o => {
+        let x=m;
+        while(x){
+          if(x===o.mesh) return true;
+          x=x.parent;
+        }
+        return false;
+      });
+      if(found) selectObj(found.id);
+    }
+  });
+}
+
+// ======= Shortcuts =======
+function initShortcuts(){
+  window.addEventListener('keydown', (e)=>{
+    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA')) return;
+
+    if(e.key === 'Delete' || e.key === 'Backspace'){
+      deleteActive();
+    }
+    if(e.key.toLowerCase() === 'g') transformControl.setMode('translate');
+    if(e.key.toLowerCase() === 'r') transformControl.setMode('rotate');
+    if(e.key.toLowerCase() === 's') transformControl.setMode('scale');
+    if(e.key === 'Escape') transformControl.detach();
+  });
+}
+
+// ======= GIF playback =======
+function tickGifs(dt){
+  for(const o of objects){
+    if(!o.gif) continue;
+    const g=o.gif;
+    g.t += dt;
+    if(g.t < 1/24) continue;
+    g.t = 0;
+    g.r.decodeAndBlitFrameRGBA(g.f, g.dat.data);
+    g.ctx.putImageData(g.dat,0,0);
+    g.tex.needsUpdate = true;
+    g.f = (g.f+1) % g.num;
+  }
+}
+
+// ======= VR SETUP =======
+function setupVR() {
+  if('xr' in navigator) {
+    navigator.xr.isSessionSupported('immersive-ar').then(s=>{
+      if(s) {
+        const b=document.getElementById('vrBtn');
+        b.style.display='block';
+        b.onclick=startVR;
+      }
+    });
+  }
+}
+
+function handleOcclusionToggle(e) {
+  occlusionEnabled = e.target.checked;
+  if(xrSession) {
+    pendingXRRestart = true;
+    xrSession.end();
+  }
+}
+
+async function startVR() {
+  occlusionEnabled = document.getElementById('checkOcclusion').checked;
+  const sessionInit = {
+    requiredFeatures: ['local-floor'],
+    optionalFeatures: ['dom-overlay'],
+    domOverlay: { root: document.body }
+  };
+
+  if(occlusionEnabled) {
+    sessionInit.optionalFeatures.push('depth-sensing');
+    sessionInit.depthSensing = {
+      usagePreference: ["gpu-optimized", "cpu-optimized"],
+      dataFormatPreference: ["luminance-alpha"]
+    };
+  }
+
+  try {
+    xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
+    renderer.xr.setSession(xrSession);
+    setMode(true);
+
+    xrSession.addEventListener('end', ()=>{
+      xrSession=null;
+      setMode(false);
+      if(pendingXRRestart) {
+        pendingXRRestart = false;
+        startVR();
+      }
+    });
+  } catch(err) {
+    console.error('Error iniciando XR:', err);
+    alert('No se pudo iniciar MR. Verifica permisos y soporte del dispositivo.');
+  }
+}
+
+// ======= CONTROLES VR =======
+function initRay() {
+  rightRay = new THREE.Line(
+    new THREE.BufferGeometry().setFromPoints([
+      new THREE.Vector3(0,0,0),
+      new THREE.Vector3(0,0,-5)
+    ]),
+    new THREE.LineBasicMaterial({color:0x6c5ce7, linewidth:3})
+  );
+  scene.add(rightRay);
+
+  rayCursor = new THREE.Mesh(
+    new THREE.SphereGeometry(0.03),
+    new THREE.MeshBasicMaterial({color:0xff7675})
+  );
+  scene.add(rayCursor);
+}
+
+function handleVR(frame, dt) {
+  if(!xrSession) return;
+  const ref = renderer.xr.getReferenceSpace();
+  let lSrc, rSrc;
+  for(const s of xrSession.inputSources) {
+    if(s.handedness==='left') lSrc=s;
+    if(s.handedness==='right') rSrc=s;
+  }
+
+  if(rSrc && rSrc.gripSpace) {
+    const p = frame.getPose(rSrc.gripSpace, ref);
+    if(p) {
+      const pos = p.transform.position;
+      rightRay.position.set(pos.x,pos.y,pos.z);
+      rightRay.quaternion.set(
+        p.transform.orientation.x,
+        p.transform.orientation.y,
+        p.transform.orientation.z,
+        p.transform.orientation.w
+      );
+      rightRay.visible = true;
+
+      const orig = new THREE.Vector3(pos.x, pos.y, pos.z);
+      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(rightRay.quaternion);
+      const targets = objects.map(o=>o.mesh);
+      const hits = new THREE.Raycaster(orig, dir, 0, 10).intersectObjects(targets, true);
+
+      if(hits.length>0) {
+        rayCursor.visible = true;
+        rayCursor.position.copy(hits[0].point);
+        let m = hits[0].object;
+        const found = objects.find(o => {
+          let x=m;
+          while(x){
+            if(x===o.mesh)return true;
+            x=x.parent;
+          }
+          return false;
+        });
+        hoverId = found ? found.id : null;
+      } else {
+        rayCursor.visible=false;
+        hoverId=null;
+      }
+
+      ctrl.right.currPos = orig;
+      ctrl.right.currQuat = rightRay.quaternion.clone();
+    }
+  }
+
+  if(rSrc && rSrc.gamepad) {
+    const gp = rSrc.gamepad;
+    const trig = gp.buttons[0].pressed;
+    const grip = gp.buttons[1].pressed;
+    const btnA = gp.buttons[4]?.pressed || gp.buttons[5]?.pressed;
+
+    if(trig && !ctrl.right.lastTrig && hoverId) {
+      selectObj(hoverId);
+    }
+    ctrl.right.lastTrig = trig;
+
+    if(btnA && !ctrl.right.lastBtn && activeId) {
+      const o = objects.find(x=>x.id===activeId);
+      if(o && o.video) {
+        if(o.video.paused) o.video.play();
+        else o.video.pause();
+      } else if(o && o.type==='audio' && o.audio) {
+        if(o.audio.isPlaying) o.audio.pause();
+        else o.audio.play();
+      }
+    }
+    ctrl.right.lastBtn = btnA;
+
+    const sx = gp.axes[2]||0;
+    const sy = gp.axes[3]||0;
+
+    if(grip) {
+      const obj = objects.find(o=>o.id===activeId);
+      if(obj) {
+        if(obj.settings.projection==='plane'||obj.type==='model'||obj.type==='audio') {
+          if(Math.abs(sx)>0.1) obj.mesh.position.x += sx*dt*2;
+          if(Math.abs(sy)>0.1) obj.mesh.position.z += sy*dt*2;
+          if(ctrl.right.gripped) {
+            const dQ = ctrl.right.currQuat.clone().multiply(ctrl.right.lastQuat.clone().invert());
+            obj.mesh.quaternion.premultiply(dQ);
+            syncUI();
+          }
+        }
+
+        if(lSrc && lSrc.gamepad) {
+          const lGrip = lSrc.gamepad.buttons[1].pressed;
+          const lsy = lSrc.gamepad.axes[3]||0;
+          if(Math.abs(lsy)>0.1 && (obj.settings.projection==='plane'||obj.type==='model'||obj.type==='audio')) {
+            obj.mesh.position.y -= lsy*dt;
+            syncUI();
+          }
+
+          if(lGrip) {
+            const lp = frame.getPose(lSrc.gripSpace, ref);
+            if(lp) {
+              const lPos = new THREE.Vector3(
+                lp.transform.position.x,
+                lp.transform.position.y,
+                lp.transform.position.z
+              );
+              const d = lPos.distanceTo(ctrl.right.currPos);
+              if(!ctrl.left.gripped) {
+                ctrl.gesture.startDist=d;
+                ctrl.gesture.startScale=obj.settings.scale;
+              } else {
+                const ns = Math.max(0.01, ctrl.gesture.startScale * (d/ctrl.gesture.startDist));
+                updateObj('scale', ns);
+              }
+            }
+            ctrl.left.gripped = true;
+          } else {
+            ctrl.left.gripped = false;
+          }
+        }
+      }
+      ctrl.right.gripped = true;
+      ctrl.right.lastQuat.copy(ctrl.right.currQuat);
+    } else {
+      ctrl.right.gripped = false;
+    }
+  }
+}
+
+function syncFromTransform() {
+  const o = objects.find(x=>x.id===activeId);
+  if(!o) return;
+  const p = o.mesh.position;
+  if(o.type === 'audio') {
+    // position driven by gizmo only
+    return;
+  }
+  if(o.settings.projection==='plane' || o.type==='model') {
+    o.settings.dist = -p.z;
+    o.settings.height = p.y;
+  } else {
+    o.settings.surfaceOffsetX = p.x;
+    o.settings.surfaceHeight = p.y;
+    o.settings.surfaceOffsetZ = p.z;
+  }
+  syncUI();
+}
+
+// ======= Audio controls =======
+function initAudioControls() {
+  document.getElementById('audioPlayPause').onclick = ()=>{
+    const o = objects.find(x=>x.id===activeId && x.type==='audio');
+    if(!o || !o.audio) return;
+    if(o.audio.isPlaying) o.audio.pause(); else o.audio.play();
+  };
+  document.getElementById('audioStop').onclick = ()=>{
+    const o = objects.find(x=>x.id===activeId && x.type==='audio');
+    if(!o || !o.audio) return;
+    o.audio.stop();
+  };
+}
+
+function applyAudioSetting(o, key, value) {
+  const s = o.settings;
+  const audio = o.audio;
+  s[key] = value;
+  if(!audio) return;
+  switch(key) {
+    case 'audioVolume': audio.setVolume(value); break;
+    case 'audioLoop': audio.setLoop(value); break;
+    case 'audioSpace':
+      if(value === 'global') {
+        audio.setRolloffFactor(0);
+        audio.setRefDistance(1e6);
+      } else {
+        audio.setRolloffFactor(s.audioRolloff ?? 1);
+        audio.setRefDistance(s.audioRefDistance ?? 2);
+      }
+      break;
+    case 'audioRefDistance':
+      if(s.audioSpace === '3d') audio.setRefDistance(value);
+      break;
+    case 'audioRolloff':
+      if(s.audioSpace === '3d') audio.setRolloffFactor(value);
+      break;
+    case 'audioLow':
+      if(o.filters?.[0]) o.filters[0].gain.value = value;
+      break;
+    case 'audioMid':
+      if(o.filters?.[1]) o.filters[1].gain.value = value;
+      break;
+    case 'audioHigh':
+      if(o.filters?.[2]) o.filters[2].gain.value = value;
+      break;
+  }
+}
+
+// ======= Shader controls =======
+function initShaderControls() {
+  document.getElementById('applyShaderBtn').onclick = applyShaderSnippet;
+  document.getElementById('resetShaderBtn').onclick = () => {
+    document.getElementById('shaderEditor').value = defaultShaderSnippet;
+    applyShaderSnippet();
+  };
+  document.getElementById('loadShaderBtn').onclick = ()=>document.getElementById('shaderFile').click();
+  document.getElementById('shaderFile').addEventListener('change', async e=>{
+    if(!e.target.files.length) return;
+    const txt = await e.target.files[0].text();
+    document.getElementById('shaderEditor').value = txt;
+    applyShaderSnippet();
+    e.target.value = '';
+  });
+}
+
+function applyShaderSnippet() {
+  const o = objects.find(x=>x.id===activeId);
+  if(!o || o.type==='model' || o.type==='audio') return;
+  const txt = document.getElementById('shaderEditor').value || defaultShaderSnippet;
+  o.settings.shaderSnippet = txt;
+  updateObj('shaderSnippet', txt);
+}
+
+// ======= Render loop =======
+let lastT = performance.now();
+function render(t, frame) {
+  const dt = Math.min(0.05, (t-lastT)/1000);
+  lastT = t;
+
+  if(!xrSession) orbit.update();
+
+  tickGifs(dt);
+
+  for(const o of objects){
+    if(o.type === 'model' || o.type === 'audio') continue;
+    const s=o.settings;
+    if((s.projection==='360' || s.projection==='180') && s.followViewer){
+      const cam = renderer.xr.isPresenting ? renderer.xr.getCamera(camera) : camera;
+      o.mesh.position.copy(cam.position);
+      o.mesh.position.x += s.surfaceOffsetX;
+      o.mesh.position.y += s.surfaceHeight;
+      o.mesh.position.z += s.surfaceOffsetZ;
+    }
+  }
+
+  if(frame) handleVR(frame, dt);
+
+  renderer.render(scene, camera);
+}
+
+init();
+</script>
+</body>
+</html>

